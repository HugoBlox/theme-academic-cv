<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Unity | アプリNaviブログ</title><link>https://blog.opuappnavi.com/tag/unity/</link><atom:link href="https://blog.opuappnavi.com/tag/unity/index.xml" rel="self" type="application/rss+xml"/><description>Unity</description><generator>Wowchemy (https://wowchemy.com)</generator><language>ja</language><lastBuildDate>Sat, 24 Sep 2022 20:30:00 +0900</lastBuildDate><image><url>https://blog.opuappnavi.com/media/icon_hude4548ff0fbec708553074fd5e552c37_155941_512x512_fill_lanczos_center_3.png</url><title>Unity</title><link>https://blog.opuappnavi.com/tag/unity/</link></image><item><title>迷路の自動生成と自動探索（Unity）</title><link>https://blog.opuappnavi.com/post/syota-kawaguchi-2022/</link><pubDate>Sat, 24 Sep 2022 20:30:00 +0900</pubDate><guid>https://blog.opuappnavi.com/post/syota-kawaguchi-2022/</guid><description>&lt;h1 id="はじめに">はじめに&lt;/h1>
&lt;p>夏休みにアプリNaviでAdvent Calendar的なものをすることになり、Unityで迷路の自動生成と自動探索を実装してみましたので、今回はそれを記事に書いていこうと思います。(といっても他の記事からロジックを拝借して実装しただけですが&amp;hellip;)&lt;/p>
&lt;h1 id="迷路の自動生成">迷路の自動生成&lt;/h1>
&lt;p>まず迷路の自動生成を行います。迷路の自動生成は以下の記事から棒倒し法のロジックを拝借いたしました。棒倒し法で生成した迷路をUnityで実体化しております。&lt;br>
棒倒し法について知りたい方は以下の記事を参考にしてください。&lt;/p>
&lt;p>&lt;a href="https://algoful.com/Archive/Algorithm/MazeExtend" target="_blank" rel="noopener">アルゴリズム初心者向けの基礎と入門(C#, Pythonとか)&lt;/a>&lt;/p>
&lt;h1 id="迷路の自動探索">迷路の自動探索&lt;/h1>
&lt;p>続いて迷路の探索について書いていきます。&lt;br>
迷路の探索ロジックは以下の２つが有名です。&lt;/p>
&lt;ul>
&lt;li>深さ優先探索(Depth First)&lt;/li>
&lt;li>幅優先探索(Breadth First)&lt;/li>
&lt;/ul>
&lt;br>
&lt;h2 id="深さ優先探索">深さ優先探索&lt;/h2>
&lt;p>　深さ優先探索ではStackというデータ構造を使います。Stackはデータの出し入れが後入れ先出し方式(Last In First Out)となっております。&lt;br>
　例えば皿洗いをしている際、洗い終わった皿を上に積んでいくとします。皿を洗い終わったあと棚にしまう際、お皿の上からしまうと思います。最後に洗い終わった皿からしまうので「後入れ先出し」というわけです。&lt;br>
　なお、Stackにデータを入れることをPush、データを取り出すことをPopといいます。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img alt="画像" srcset="
/post/syota-kawaguchi-2022/LastInFirstOut_huabb40cf8f270c816af22caf875704285_254584_a68224e191b6da23d5e97cb1e5545e1c.webp 400w,
/post/syota-kawaguchi-2022/LastInFirstOut_huabb40cf8f270c816af22caf875704285_254584_287ecef22201b31734505dd1df1f472e.webp 760w,
/post/syota-kawaguchi-2022/LastInFirstOut_huabb40cf8f270c816af22caf875704285_254584_1200x1200_fit_q75_h2_lanczos_3.webp 1200w"
src="https://blog.opuappnavi.com/post/syota-kawaguchi-2022/LastInFirstOut_huabb40cf8f270c816af22caf875704285_254584_a68224e191b6da23d5e97cb1e5545e1c.webp"
width="760"
height="428"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>深さ優先探索のアルゴリズムは以下のとおりです&lt;/p>
&lt;ol>
&lt;li>現在地をすでに通ったマスに設定後、現在地から移動可能なマス(壁ではない＆すでに通ったマスではない)を取得する。(マスが見つかり次第、移動可能なマスの探索は終了する)&lt;/li>
&lt;li>進めるマスがあれば現在地をStackにPushし、現在地を1で取得したマスに変更する。&lt;/li>
&lt;li>進めるマスがなければスタックからPopし、そのマスを現在地とする。(前のマスに戻る処理)&lt;/li>
&lt;li>ゴールするまで1 ~ 3を繰り返す&lt;/li>
&lt;/ol>
&lt;p>なお、深さ優先探索の実装ではStackの中身が0個になった時点でゴールまでのルートなしとして処理を止めています。&lt;/p>
&lt;p>迷路の経路に探索される順番を割り当てると以下の図のようになります。(方向の優先度は適当)&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img alt="画像" srcset="
/post/syota-kawaguchi-2022/DepthFirst_hu214f3ce13b0fc97822fefa89111c7ec5_11310_e1037dcd310ff69e8f5b9a7906c2494e.webp 400w,
/post/syota-kawaguchi-2022/DepthFirst_hu214f3ce13b0fc97822fefa89111c7ec5_11310_19e65fe38f899951796dd8ebbe3aee79.webp 760w,
/post/syota-kawaguchi-2022/DepthFirst_hu214f3ce13b0fc97822fefa89111c7ec5_11310_1200x1200_fit_q75_h2_lanczos_3.webp 1200w"
src="https://blog.opuappnavi.com/post/syota-kawaguchi-2022/DepthFirst_hu214f3ce13b0fc97822fefa89111c7ec5_11310_e1037dcd310ff69e8f5b9a7906c2494e.webp"
width="270"
height="279"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>図より行き止まりまでまっすぐに探索していることがわかると思います。&lt;br>&lt;/p>
&lt;p>深さ優先探索では次のような特徴があります。&lt;/p>
&lt;ul>
&lt;li>迷路と探索の優先度によって早く経路を求めることができる&lt;/li>
&lt;li>メモリの消費量が少ない。&lt;/li>
&lt;li>迷路と探索の優先度によって計算時間が大きくなる。&lt;/li>
&lt;li>求めた経路が最短経路であるとは限らない&lt;/li>
&lt;/ul>
&lt;br>
&lt;h2 id="幅優先探索">幅優先探索&lt;/h2>
&lt;p>　
　幅優先探索ではQueue(キュー)というデータ構造を使います。Queueはデータの出し入れが先入れ先出し方式(First In First Out)となっております。&lt;br>
　コンビニやスーパーのレジをイメージするとわかりやすいと思います。レジでは先に並んだお客さんから精算されますが、Queueもデータを取り出す際、先に入れられたデータから取り出されます。
　なお、Queueにデータを入れることをEnqueue(エンキュー)、データを取り出すことをDequeue(デキュー)と言います。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img alt="画像" srcset="
/post/syota-kawaguchi-2022/Queue_hu789c7561cf84da3a05931861506322e6_175845_c0084cdd14aaae5ddd828d638a988320.webp 400w,
/post/syota-kawaguchi-2022/Queue_hu789c7561cf84da3a05931861506322e6_175845_a1888890ff01e5902a0bb6c945dcc7a9.webp 760w,
/post/syota-kawaguchi-2022/Queue_hu789c7561cf84da3a05931861506322e6_175845_1200x1200_fit_q75_h2_lanczos_3.webp 1200w"
src="https://blog.opuappnavi.com/post/syota-kawaguchi-2022/Queue_hu789c7561cf84da3a05931861506322e6_175845_c0084cdd14aaae5ddd828d638a988320.webp"
width="550"
height="321"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>幅優先探索のアルゴリズムは以下のとおりです。&lt;/p>
&lt;ol>
&lt;li>現在地をすでに通ったマスに設定後、現在地から移動可能なマスをすべて取得する。&lt;/li>
&lt;li>取得した移動可能なマスをすべてQueueに格納する。このとき、移動可能なマスがどこマスから来たのか記録しておく。(のちに最短経路を求める際に利用)&lt;/li>
&lt;li>Queueからマスを一つ取り出し、現在地とする。&lt;/li>
&lt;li>ゴールするまで1~3を繰り返す。&lt;/li>
&lt;/ol>
&lt;p>なお、深さ優先探索と同様Queueの中身が0個になった時点でゴールまでのルートなしとして処理を止めています。&lt;/p>
&lt;p>迷路の経路に幅優先探索で探索される順番を割り当てると以下の図のようになります。(方向の優先度は適当)&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img alt="画像" srcset="
/post/syota-kawaguchi-2022/BreadthFirst_hu93ce28bb9d6af05f9bdbdc0650f5351a_9692_610dc635a0e1b9187642e4ac0f0ee182.webp 400w,
/post/syota-kawaguchi-2022/BreadthFirst_hu93ce28bb9d6af05f9bdbdc0650f5351a_9692_7ff90f07d78b1bdcde89f28d4d0cd2e8.webp 760w,
/post/syota-kawaguchi-2022/BreadthFirst_hu93ce28bb9d6af05f9bdbdc0650f5351a_9692_1200x1200_fit_q75_h2_lanczos_3.webp 1200w"
src="https://blog.opuappnavi.com/post/syota-kawaguchi-2022/BreadthFirst_hu93ce28bb9d6af05f9bdbdc0650f5351a_9692_610dc635a0e1b9187642e4ac0f0ee182.webp"
width="270"
height="279"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;p>図よりスタート地点から広がっていくように探索されていることがわかると思います。&lt;/p>
&lt;p>幅優先探索では次のような特徴があります。&lt;/p>
&lt;ul>
&lt;li>安定した時間で経路を求めることができる。&lt;/li>
&lt;li>常に最短経路を求めることができる。&lt;/li>
&lt;li>迷路によっては計算時間が大きくなる(複雑な地形や大きな迷路など)。&lt;/li>
&lt;li>メモリの消費量が大きい&lt;/li>
&lt;/ul>
&lt;h1 id="実装">実装&lt;/h1>
&lt;p>まず、棒倒し法をつかって迷路の自動生成をしていきます。int型の２次元配列で返すようにしています。0を通路、1を壁としています。&lt;/p>
&lt;details>
&lt;summary>コード&lt;/summary>
&lt;pre>&lt;code class="language-C#">using System;
using System.Text;
using UnityEngine;
public class Maze
{
const int PATH = 0;
const int WALL = 1;
public static int[,] Generate(int width, int height) {
// 5未満のサイズでは生成できない
if (height &amp;lt; 5 || width &amp;lt; 5) throw new ArgumentOutOfRangeException();
if (width % 2 == 0) width++;
if (height % 2 == 0) height++;
// 指定サイズで生成し外周を壁にする
var maze = new int[width, height];
for (int x = 0; x &amp;lt; width; x++)
for (int y = 0; y &amp;lt; height; y++)
if (x == 0 || y == 0 || x == width - 1 || y == height - 1)
maze[x, y] = WALL; // 外周はすべて壁
else
maze[x, y] = PATH; // 外周以外は通路
// 棒を立て、倒す
var rnd = new System.Random();
for (int x = 2; x &amp;lt; width - 1; x += 2) {
for (int y = 2; y &amp;lt; height - 1; y += 2) {
maze[x, y] = WALL; // 棒を立てる
// 倒せるまで繰り返す
while (true) {
// 1行目のみ上に倒せる
int direction;
if (y == 2)
direction = rnd.Next(4);
else
direction = rnd.Next(3);
// 棒を倒す方向を決める
int WALLX = x;
int WALLY = y;
switch (direction) {
case 0: // 右
WALLX++;
break;
case 1: // 下
WALLY++;
break;
case 2: // 左
WALLX--;
break;
case 3: // 上
WALLY--;
break;
}
// 壁じゃない場合のみ倒して終了
if (maze[WALLX, WALLY] != WALL) {
maze[WALLX, WALLY] = WALL;
break;
}
}
}
}
return maze;
}
public static void DebugPrint(int[,] maze) {
StringBuilder sb = new StringBuilder();
for (int y = maze.GetLength(0) - 1; 0 &amp;lt;= y; y--) {
for (int x = 0; x &amp;lt; maze.GetLength(1); x++) {
sb.Append($&amp;quot;{maze[x, y]}, &amp;quot;);
}
sb.Append(&amp;quot;\n&amp;quot;);
}
Debug.Log(sb);
}
}
&lt;/code>&lt;/pre>
&lt;/details>
&lt;br>
&lt;p>つづいて探索の実装です。深さ優先探索、幅優先探索をそれぞれ実装しています。&lt;/p>
&lt;details>
&lt;summary>コード&lt;/summary>
&lt;pre>&lt;code class="language-C#">using System.Collections;
using System.Collections.Generic;
using System;
using UnityEngine;
public class Searcher
{
const int PATH = 0;
const int WALL = 1;
const int GOAL = 2;
const int ALREADYPASS = 1;
private int[,] maze;
//通過した経路を記録する配列。
//0:通過していない通路, 1:通過した通路または壁
int[,] passedCells;
public Searcher(int[,] maze) {
this.maze = maze;
passedCells = new int[maze.GetLength(0), maze.GetLength(1)];
}
//深さ優先探索
public Tuple&amp;lt;int, int&amp;gt;[] DepthFirst(Tuple&amp;lt;int, int&amp;gt; startPos, Tuple&amp;lt;int, int&amp;gt; goal) {
if (maze[startPos.Item1, startPos.Item2] != PATH) {
throw new Exception(&amp;quot;開始地点が通路ではありません&amp;quot;);
}
if (maze[goal.Item1, goal.Item2] != PATH) {
throw new Exception(&amp;quot;ゴールが通路ではありません&amp;quot;);
}
var stack = new Stack&amp;lt;Tuple&amp;lt;int, int&amp;gt;&amp;gt;();
var currentPos = startPos;
maze[goal.Item1, goal.Item2] = GOAL;
Array.Copy(maze, passedCells, maze.Length);
while (true) {
passedCells[currentPos.Item1, currentPos.Item2] = 1;
var nextPos = GetCandidate(currentPos);
Maze.DebugPrint(passedCells);
if (nextPos == null) {
if (stack.Count == 0) break;
currentPos = stack.Pop();
continue;
}
stack.Push(currentPos);
currentPos = nextPos;
if (maze[currentPos.Item1, currentPos.Item2] == GOAL) {
stack.Push(currentPos);
break;
}
}
var route = stack.ToArray();
Array.Reverse(route);
return route;
}
//幅優先探索
public Tuple&amp;lt;int, int&amp;gt;[] BreadthFirst(Tuple&amp;lt;int, int&amp;gt; startPos, Tuple&amp;lt;int, int&amp;gt; goal) {
if (maze[startPos.Item1, startPos.Item2] != PATH) {
throw new Exception(&amp;quot;開始地点が通路ではありません&amp;quot;);
}
if (maze[goal.Item1, goal.Item2] != PATH) {
throw new Exception(&amp;quot;ゴールが通路ではありません&amp;quot;);
}
var isGoal = false;
var queue = new Queue&amp;lt;Tuple&amp;lt;int, int&amp;gt;&amp;gt;();
//進めるマスがどこから来たか記録する辞書型
var dict = new Dictionary&amp;lt;Tuple&amp;lt;int, int&amp;gt;, Tuple&amp;lt;int, int&amp;gt;&amp;gt;();
var currentPos = startPos;
maze[goal.Item1, goal.Item2] = GOAL;
Array.Copy(maze, passedCells, maze.Length);
while (true) {
passedCells[currentPos.Item1, currentPos.Item2] = 1;
var candidates = GetCandidates(currentPos);
foreach (var candidate in candidates) {
queue.Enqueue(candidate);
dict[candidate] = currentPos;
}
if (queue.Count == 0) break;
currentPos = queue.Dequeue();
if (maze[currentPos.Item1, currentPos.Item2] == GOAL) {
isGoal = true;
break;
}
}
var route = new List&amp;lt;Tuple&amp;lt;int, int&amp;gt;&amp;gt;();
while (isGoal) {
route.Insert(0, currentPos);
if (currentPos == startPos) break;
currentPos = dict[currentPos];
}
return route.ToArray();
}
//現在地から移動可能なマスを取得する
private Tuple&amp;lt;int, int&amp;gt; GetCandidate(Tuple&amp;lt;int, int&amp;gt; cell) {
if (IsNotWALL(cell.Item1 + 1, cell.Item2) &amp;amp;&amp;amp; !IsAlreadyPassed(cell.Item1 + 1, cell.Item2)) return new Tuple&amp;lt;int, int&amp;gt;(cell.Item1 + 1, cell.Item2);
if (IsNotWALL(cell.Item1, cell.Item2 + 1) &amp;amp;&amp;amp; !IsAlreadyPassed(cell.Item1, cell.Item2 + 1)) return new Tuple&amp;lt;int, int&amp;gt;(cell.Item1, cell.Item2 + 1);
if (IsNotWALL(cell.Item1 - 1, cell.Item2) &amp;amp;&amp;amp; !IsAlreadyPassed(cell.Item1 - 1, cell.Item2)) return new Tuple&amp;lt;int, int&amp;gt;(cell.Item1 - 1, cell.Item2);
if (IsNotWALL(cell.Item1, cell.Item2 - 1) &amp;amp;&amp;amp; !IsAlreadyPassed(cell.Item1, cell.Item2 - 1)) return new Tuple&amp;lt;int, int&amp;gt;(cell.Item1, cell.Item2 - 1);
return null;
}
private List&amp;lt;Tuple&amp;lt;int, int&amp;gt;&amp;gt; GetCandidates(Tuple&amp;lt;int, int&amp;gt; cell) {
var result = new List&amp;lt;Tuple&amp;lt;int, int&amp;gt;&amp;gt;();
if (IsNotWALL(cell.Item1 + 1, cell.Item2) &amp;amp;&amp;amp; !IsAlreadyPassed(cell.Item1 + 1, cell.Item2)) result.Add(new Tuple&amp;lt;int, int&amp;gt;(cell.Item1 + 1, cell.Item2));
if (IsNotWALL(cell.Item1, cell.Item2 + 1) &amp;amp;&amp;amp; !IsAlreadyPassed(cell.Item1, cell.Item2 + 1)) result.Add(new Tuple&amp;lt;int, int&amp;gt;(cell.Item1, cell.Item2 + 1));
if (IsNotWALL(cell.Item1 - 1, cell.Item2) &amp;amp;&amp;amp; !IsAlreadyPassed(cell.Item1 - 1, cell.Item2)) result.Add(new Tuple&amp;lt;int, int&amp;gt;(cell.Item1 - 1, cell.Item2));
if (IsNotWALL(cell.Item1, cell.Item2 - 1) &amp;amp;&amp;amp; !IsAlreadyPassed(cell.Item1, cell.Item2 - 1)) result.Add(new Tuple&amp;lt;int, int&amp;gt;(cell.Item1, cell.Item2 - 1));
return result;
}
private bool IsNotWALL(int x, int y) {
return (0 &amp;lt;= x &amp;amp;&amp;amp; x &amp;lt; maze.GetLength(0)) &amp;amp;&amp;amp; (0 &amp;lt;= y &amp;amp;&amp;amp; y &amp;lt; maze.GetLength(1)) &amp;amp;&amp;amp; maze[x, y] != WALL;
}
private bool IsAlreadyPassed(int x, int y) {
return passedCells[x, y] == ALREADYPASS;
}
}
&lt;/code>&lt;/pre>
&lt;/details>
&lt;br>
&lt;p>最後に呼び出し側の実装です。まず、Mazeクラスから迷路の作成結果を受け取り、オブジェクトを配置しています。配置が完了すると自動探索でゴールまでの経路を導き、受け取った経路をもとにPlayerオブジェクトを動かしています。&lt;/p>
&lt;details>
&lt;summary>コード&lt;/summary>
&lt;pre>&lt;code class="language-C#">using System.Collections;
using System.Collections.Generic;
using System;
using UnityEngine;
enum Mode {
DepthFirst,
BreadthFirst
}
public class Generator : MonoBehaviour
{
[SerializeField] private Mode mode = Mode.DepthFirst;
int[,] maze;
[SerializeField] private int width = 7;
[SerializeField] private int height = 7;
[SerializeField] private GameObject wall;
[SerializeField] private GameObject playerPrefab;
const int PATH = 0;
const int WALL = 1;
IEnumerator Start()
{
var maze = Maze.Generate(width, height);
Debug.Log(&amp;quot;Maze is generated&amp;quot;);
Maze.DebugPrint(maze);
yield return StartCoroutine(GenerateStage(maze));
var searcher = new Searcher(maze);
var startPos = new Tuple&amp;lt;int, int&amp;gt;(1, 1);
var goalPos = new Tuple&amp;lt;int, int&amp;gt;(5, 5);
var route = mode == Mode.DepthFirst ?
searcher.DepthFirst(startPos, goalPos) :
searcher.BreadthFirst(startPos, goalPos);
Debug.Log($&amp;quot;route length : {route.Length}&amp;quot;);
foreach(var cell in route) {
Debug.Log($&amp;quot;x:{cell.Item1}, y:{cell.Item2}&amp;quot;);
}
yield return StartCoroutine(Go(route));
}
private IEnumerator GenerateStage(int[,] maze) {
int wallSizeX = 1;
int wallSizeZ= 1;
for (int i = 0; i &amp;lt; maze.GetLength(0); i++) {
for (int j = 0; j &amp;lt; maze.GetLength(1); j++) {
if (maze[i, j] == WALL) {
Instantiate(wall, new Vector3(wallSizeX * i, 0.25f, wallSizeZ * j), Quaternion.identity);
yield return new WaitForSeconds(0.1f);
}
}
}
}
private IEnumerator Go(Tuple&amp;lt;int, int&amp;gt;[] route) {
var player = Instantiate(playerPrefab, new Vector3(route[0].Item1, 1, route[0].Item2), Quaternion.identity);
for (int i = 1; i &amp;lt; route.Length; i++) {
player.transform.position = new Vector3(route[i].Item1, 1, route[i].Item2);
Debug.Log($&amp;quot;i:{i}, position({route[i].Item1}, 1, {route[i].Item2})&amp;quot;);
yield return new WaitForSeconds(0.5f);
}
}
}
&lt;/code>&lt;/pre>
&lt;/details>
&lt;br>
&lt;p>以下の画像はMazeクラスで作成した迷路をもとにUnity上にオブジェクトを配置した結果です。&lt;/p>
&lt;p>
&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img alt="画像" srcset="
/post/syota-kawaguchi-2022/MazeGenerated_huf542778ba76cacef68703605ac9c3b33_26779_34d540d5f7af82bf0c04a4b570df0fe0.webp 400w,
/post/syota-kawaguchi-2022/MazeGenerated_huf542778ba76cacef68703605ac9c3b33_26779_066ccfc2768d8c52aa3e69468e8e6807.webp 760w,
/post/syota-kawaguchi-2022/MazeGenerated_huf542778ba76cacef68703605ac9c3b33_26779_1200x1200_fit_q75_h2_lanczos_3.webp 1200w"
src="https://blog.opuappnavi.com/post/syota-kawaguchi-2022/MazeGenerated_huf542778ba76cacef68703605ac9c3b33_26779_34d540d5f7af82bf0c04a4b570df0fe0.webp"
width="490"
height="446"
loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;/p>
&lt;h2 id="最後に">最後に&lt;/h2>
&lt;p>今回は迷路を自動生成し、探索アルゴリズムを用いてゴールまでの経路を求めてみました。配列からUnityへの座標変換で少し手こずりましたがなんとか実装できたと思います。もし間違いやもっとこうしたほうが良いというアドバイスがありましたら、アプリNavi宛にご連絡頂けますと幸いです。
&lt;br>
&lt;br>
また今回のプロジェクトはGithubにあげておりますので、もしよろしければ御覧ください。
ここまで読んでいただきありがとうございました。&lt;/p>
&lt;p>&lt;a href="https://github.com/syota-kawaguchi/MazeSearch" target="_blank" rel="noopener">Github&lt;/a>&lt;/p></description></item><item><title>Finden die Feen 開発記録</title><link>https://blog.opuappnavi.com/post/record-findendiefeen/</link><pubDate>Mon, 22 Jun 2020 18:54:11 +0900</pubDate><guid>https://blog.opuappnavi.com/post/record-findendiefeen/</guid><description>&lt;h1 id="はじめに">はじめに&lt;/h1>
&lt;p>この記事は，2020年5月30日から31日にかけて行われた &lt;a href="https://ch-random.net/post/167/" target="_blank" rel="noopener">&lt;strong>府大バーチャル学祭&lt;/strong>&lt;/a> で展示された &lt;strong>Finden die Feen&lt;/strong> というゲームの開発記事です。どういった経緯でこのゲームが開発されたかを，この記事に書いていこうと思います。&lt;/p>
&lt;p>まずはじめに，&lt;strong>Finden die Feen&lt;/strong> とは以下のようなゲームです。
&lt;blockquote class="twitter-tweet">&lt;p lang="ja" dir="ltr">&lt;a href="https://twitter.com/hashtag/%E5%BA%9C%E5%A4%A7%E3%83%90%E3%83%BC%E3%83%81%E3%83%A3%E3%83%AB%E5%AD%A6%E7%A5%AD?src=hash&amp;amp;ref_src=twsrc%5Etfw">#府大バーチャル学祭&lt;/a> &lt;br>2つ目ー！！&lt;br>タイトル：Finden die Feen&lt;br>妖精たちとのかくれんぼ&lt;br>迷路の中に隠れている見えない妖精たちを、音を頼りに探していこう！&lt;br>マウスと方向キーだけの簡単操作で遊べるよ。&lt;br>あなたは妖精たちとの遊びに最後までついていけるかな？&lt;br>&lt;br>↓↓Click！&lt;a href="https://t.co/8zEqY1KpKx">https://t.co/8zEqY1KpKx&lt;/a> &lt;a href="https://t.co/6be1bGRdb0">pic.twitter.com/6be1bGRdb0&lt;/a>&lt;/p>&amp;mdash; OMU アプリNavi (@OMUAppNavi) &lt;a href="https://twitter.com/OMUAppNavi/status/1266598410095751169?ref_src=twsrc%5Etfw">May 30, 2020&lt;/a>&lt;/blockquote>
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8">&lt;/script>
&lt;/p>
&lt;p>上記のように，迷路の中で音を頼りに妖精さんを探す &lt;strong>PC用ゲーム&lt;/strong> です。まだ遊んだことのない方は，以下から遊ぶことができます。ぜひ遊んでみてからこの記事を読んでみてください。(音量注意！！！)&lt;/p>
&lt;div id="unity_webgl_1_1" style="width: 100%; margin: 15px 0; background: white; border-radius: 15px;">
&lt;div style="position: relative;">
&lt;div id="unity_webgl_1_2" style="height: 0;">
&lt;iframe id="unity_webgl_1_3" src="https://hiroyuki-nakaya.github.io/Finden-die-Feen/" allowfullscreen>&lt;/iframe>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;script>
document.getElementById("unity_webgl_1_2").style.paddingBottom = 100 * 700 / 980 + "%";
function set_width() {
const w = 980 ;
const h = 700 ;
const client_w = document.getElementById("unity_webgl_1_2").clientWidth;
const per = client_w / w;
const rev = 100 / per;
const iframe = document.getElementById("unity_webgl_1_3");
iframe.height = rev + "%";
iframe.width = rev + "%";
iframe.style = "position: absolute; top: 0; left: 0; transform:scale(" + per + ");-o-transform:scale(" + per + ");-webkit-transform:scale(" + per + ");-moz-transform:scale(" + per + ");-ms-transform:scale(" + per + ");transform-origin:top left; border: 0;"
}
set_width();
window.onresize = function(){ set_width(); };
&lt;/script>
&lt;h1 id="企画">企画&lt;/h1>
&lt;p>ここでは，どのようにして &lt;strong>Finden die Feen&lt;/strong> を思いついたのか書いていきます。普段，私は毎年5月末に行われる大学の文化祭に向けてゲームを作っており，今年は「&lt;strong>探索&lt;/strong>」というテーマでゲームを考えていました。このテーマは，「宝探しは楽しいよね！」と「あまりゲームが得意でない人でも遊べるゲーム」を両立させようという目論見がありました。そこで何かいい案はないかと&lt;a href="https://www.borndigital.co.jp/book/6633.html" target="_blank" rel="noopener">Unityゲーム プログラミング・バイブル&lt;/a>という本をパラパラめくっていたところ，5章の「3D迷路」の部分を読み，「ここに書いてある迷路生成プログラムを用いれば &lt;strong>簡単に迷路が作れる&lt;/strong> のでは？」と思い，該当部分をステージ生成の基礎として，迷路の中でもの探しをするというゲームを思いつきました。&lt;/p>
&lt;p>ただし，単に迷路を探索するだけでは既存の迷路ゲームと変わらず，&lt;a href="https://www.borndigital.co.jp/book/6633.html" target="_blank" rel="noopener">Unityゲーム プログラミング・バイブル&lt;/a>の「3D迷路」の章のパクりとなり，なんら面白くありません。そこで，任天堂が2003年に発売した「&lt;strong>伝説のスタフィー2&lt;/strong>」というゲームの道中にあった「&lt;strong>音で探す&lt;/strong>」ゲームギミックを参考にしました。
&lt;figure id="figure-伝説のスタフィー2出典httpswwwnintendocojpn08avfjgamenindexhtml">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="./blog_01.png" alt="伝説のスタフィー2（出典：https://www.nintendo.co.jp/n08/avfj/gamen/index.html）" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
伝説のスタフィー2（出典：https://www.nintendo.co.jp/n08/avfj/gamen/index.html）
&lt;/figcaption>&lt;/figure>
参考にしたギミックは「見えない探し物が近くにあればあるほど，アラームを激しく鳴らす」というものです。「伝説のスタフィー2」では，草むらに隠れた見えないターゲットを音を頼りに見つけ出すというゲーム要素があり，私自身「伝説のスタフィー2」を遊んだ時にこのギミックがとても楽しかった記憶があって，「音で探す」システムを採用しました。&lt;/p>
&lt;p>以上より「&lt;strong>音を頼りに迷路を探索し妖精さんを見つける&lt;/strong>」ゲームが企画されました。以下の画像は&lt;a href="https://www.sbcr.jp/product/4797377361/" target="_blank" rel="noopener">ゲーム作りのはじめかた Unityで覚える企画からレベルデザインまで&lt;/a>という本の「まずはゲームの企画をA4 1枚にペンで書け！」といった教えにのっとり書いた企画書です。
&lt;figure id="figure-finden-die-feen-企画書">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="./blog_02.jpg" alt="Finden die Feen 企画書" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
Finden die Feen 企画書
&lt;/figcaption>&lt;/figure>
上の企画書を見てみると，何個か夢物語が書いてありますが，「Finden die Feen」の原型は保たれてますね。また，この時点でゲームのタイトルはまだ決めていませんね。&lt;/p>
&lt;p>ちなみに，この企画書は5月のはじめに書いたものです。提出締め切りが5月30日だったので，必然的に1か月で完成させなくてはいけなく，締め切り1週間前は地獄を見ました&amp;hellip;。&lt;del>大学の文化祭が新型コロナウイルス騒ぎで中止になったと聞いて，今年はゲーム作らなくていいかと思ってたところにオンライン文化祭の通知が来たもん仕方ないね。&lt;/del>&lt;/p>
&lt;h1 id="実装">実装&lt;/h1>
&lt;h2 id="1-自動迷路生成の実装">1. 自動迷路生成の実装&lt;/h2>
&lt;p>代表的な迷路自動生成アルゴリズムには，以下の3種類があります。&lt;/p>
&lt;ul>
&lt;li>棒倒し法（比較的簡単な迷路生成）&lt;/li>
&lt;li>壁伸ばし法（複雑な迷路生成）&lt;/li>
&lt;li>穴掘り法（複雑な迷路生成）&lt;/li>
&lt;/ul>
&lt;p>この中で，「Finden die Feen」の迷路自動生成アルゴリズムには「&lt;strong>穴掘り法&lt;/strong>」を用いました。コードはたった5,000円で買える素晴らしい本，&lt;a href="https://www.borndigital.co.jp/book/6633.html" target="_blank" rel="noopener">Unityゲーム プログラミング・バイブル&lt;/a>の5章「3D迷路」に載っていたものを&lt;del>パクリ&lt;/del>参考にしました。この穴掘り法を用いると，以下の画像のように任意の大きさの複雑な迷路を勝手に生成してくれます。とても楽ですし素晴らしいですね。
&lt;figure id="figure-穴掘り法による迷路生成">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="./blog_03.png" alt="穴掘り法による迷路生成" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
穴掘り法による迷路生成
&lt;/figcaption>&lt;/figure>&lt;/p>
&lt;h2 id="2-サウンドの実装">2. サウンドの実装&lt;/h2>
&lt;p>「Finden die Feen」では，妖精の位置によって音の鳴り方が変わり，プレイヤーからどれだけ近くに妖精がいるかを教えてくれるのが特徴です。この特徴的なソナー音やBGMなど，プレイヤーの位置に依存しないサウンドは，単一のゲームオブジェクトによる一括管理を行うことを考えます。このようなサウンドシステムの実装は，&lt;strong>シングルトンパターン&lt;/strong> を用いて実装されています。つまり，ゲーム実行中は常に1つのインスタンスが存在し，サウンドに関する処理を一括して行っています。ちなみに私はこの処理を，たった4,000円で買える本，&lt;a href="https://www.borndigital.co.jp/book/15163.html" target="_blank" rel="noopener">Unity サウンド エキスパート養成講座&lt;/a>の1章のコードを&lt;del>パクって&lt;/del>参考にして実装しました。&lt;/p>
&lt;p>このような実装を行うと，音源の再生を行いたい場合に&lt;/p>
&lt;pre>&lt;code class="language-c#:">using SoundSystem;
&lt;/code>&lt;/pre>
&lt;p>と宣言して&lt;/p>
&lt;pre>&lt;code class="language-c#:">SoundManager.Instance.Play(&amp;quot;音源のタイトル&amp;quot;);
&lt;/code>&lt;/pre>
&lt;p>と任意の場所に書くと，音が再生されます。AudioSourceをGameObjectにいちいちアタッチせずに，たった1行処理を書くだけで音が再生されるので非常に便利です。&lt;/p>
&lt;h2 id="3-ムービーの実装">3. ムービーの実装&lt;/h2>
&lt;p>「Finden die Feen」では，チュートリアルや妖精を発見したときなどにムービーが流れます。
&lt;figure id="figure-ムービーシーン">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="./blog_04.png" alt="ムービーシーン" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
ムービーシーン
&lt;/figcaption>&lt;/figure>
このムービーは，Unityの &lt;strong>Timeline&lt;/strong> という機能を用いて実装しました。Timelineを用いると，簡単にムービーシーンを作ることができるため大変便利です。
&lt;figure id="figure-unityのtimeline">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="./blog_05.png" alt="UnityのTimeline" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
UnityのTimeline
&lt;/figcaption>&lt;/figure>
画像のように，動画編集みたいに時系列でプログラムを書かずにオブジェクトを操作できます。今回はTimelineを用いてテキスト表示を行うカスタムクリップを&lt;a href="https://blogs.unity3d.com/jp/2018/09/05/extending-timeline-a-practical-guide/" target="_blank" rel="noopener">Timelineの拡張 ― 実践ガイド&lt;/a>というサイトを参考に実装しました。何回かTimelineのカスタムクリップを実装したことはありますが，まともに勉強したのは初めてな気がします。&lt;/p>
&lt;p>このとき，PlayableAssetを継承したクラス，PlayableBehaviourを継承したクラス，TrackAssetを継承したクラスそれぞれファイル名とクラス名を同じにしないと，Timelineからカスタムクリップが抜け落ちるという仕様に1日悩んだのはいい思い出です。&lt;del>少し考えれば，あたりまえなんですけどね。&lt;/del>&lt;/p>
&lt;h1 id="テストプレイから公開まで">テストプレイから公開まで&lt;/h1>
&lt;p>ここでは，ゲームバランス調整について書いていこうと思います。一般論として，開発者がプレイして開発者がちょうどいいと思う難易度にすると，たいてい &lt;strong>超高難易度&lt;/strong> になります。そのため，テストプレイはできる限り第3者に行ってもらうのがオススメです。私は締め切り1日前に妹にテストプレイをしてもらい，制限時間などのパラメータを調節しました。&lt;/p>
&lt;p>ちなみにこのとき，妹から&lt;/p>
&lt;ul>
&lt;li>妖精のいる方角を示すコンパスの色の点滅&lt;/li>
&lt;li>制限時間を増やすアイテムの追加&lt;/li>
&lt;li>制限時間がなくなってきたら，BGMのピッチを上げる&lt;/li>
&lt;li>残りの妖精の数をUI表示&lt;/li>
&lt;/ul>
&lt;p>の機能を実装したほうがいいという&lt;del>地獄のような&lt;/del>素晴らしいアドバイスを &lt;strong>締め切り直前&lt;/strong> にいただき，締め切り前日の夜10時から締め切り当日の朝5時にかけて上記の機能を全て実装しました。このアドバイスによってよりゲームのクオリティが上がったと思うので妹には感謝しています。&lt;del>アドバイスをもらったときは妹にうっすら殺意を覚えましたが。&lt;/del>&lt;/p>
&lt;p>そして最後にゲームの &lt;strong>タイトル&lt;/strong> を決めました。なんでもかんでも &lt;strong>ドイツ語&lt;/strong> にするとカッコいいよねという安直な考えで，「Finden die Feen」というタイトルになりました。ちなみに英語にすると「Find the Fairies」です。「妖精を発見する」的な意味です。そのままです。このタイトルをつけるためだけに，2年ぶりにドイツ語の文法書を引っ張り出しました。&lt;del>ドイツ語の文法がおかしい？うるせえ黙れ！&lt;/del>
&lt;figure id="figure-ゲームのタイトル画面">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="./blog_06.png" alt="ゲームのタイトル画面" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
ゲームのタイトル画面
&lt;/figcaption>&lt;/figure>&lt;/p>
&lt;h1 id="最後に">最後に&lt;/h1>
&lt;p>このような感じで「Finden die Feen」は約1ヶ月という期間で製作し，府大バーチャル学祭で公開されました。個人的には，完成度がそこそこ高く見えるため気に入っています。特に気に入っているのは，以下の画像のステージです。
&lt;figure id="figure-お気に入りのステージ">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="./blog_07.png" alt="お気に入りのステージ" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
お気に入りのステージ
&lt;/figcaption>&lt;/figure>
このステージは，赤，青，緑のライトが混ざり合うステージでとても綺麗だと思ってるのですが，みなさんはどう思いましたか？私はデバッグ中，このステージに1人で感動していました。&lt;/p>
&lt;p>最後になりますが，ここまで読んで下さりありがとうございました。そしてまた改めて「Finden die Feen」で遊んでみてはいかがでしょうか？&lt;/p></description></item><item><title>Unity WebGLのゲームをローカルでプレイする方法</title><link>https://blog.opuappnavi.com/post/unity-webgl-locally/</link><pubDate>Sat, 30 May 2020 16:45:03 +0900</pubDate><guid>https://blog.opuappnavi.com/post/unity-webgl-locally/</guid><description>&lt;p>UnityでWebGLをプラットフォームに選択し、&lt;code>Build And Run&lt;/code>を押すと、ブラウザが起動して、作ったゲームをプレイすることができます。WebGLのビルドにはとても時間がかかるので、毎回ビルドするのではなく、一度ビルドしたゲームを複数回プレイしたくなります。ですが、ただ単に出力されたファイル&lt;code>index.html&lt;/code>を開くだけではプレイできません。&lt;br>
&lt;figure id="figure-indexhtmlを開くとこのようなエラーメッセージが表示される">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="./Unity_WebGL_Index_Html_Error.png" alt="index.htmlを開くと、このようなエラーメッセージが表示される" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
index.htmlを開くと、このようなエラーメッセージが表示される
&lt;/figcaption>&lt;/figure>
そこで、&lt;code>Visual Studio Code&lt;/code>(&lt;code>VSCode&lt;/code>)を使ってビルドしたゲームをプレイする方法を紹介します。&lt;br>
&lt;div class="alert alert-note">
&lt;div>
&lt;code>VSCode&lt;/code>は &lt;a href="https://code.visualstudio.com/" target="_blank" rel="noopener">https://code.visualstudio.com/&lt;/a> からダウンロードできます。
&lt;/div>
&lt;/div>
&lt;/p>
&lt;h1 id="1-拡張機能のインストール">1. 拡張機能のインストール&lt;/h1>
&lt;p>&lt;code>VSCode&lt;/code>を起動し、画面左のボタンを押して拡張機能パネルを開きます。
&lt;figure id="figure-拡張機能パネルを開くボタン">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="./VSCode_Activity_Bar_Extension.png" alt="拡張機能パネルを開くボタン" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
拡張機能パネルを開くボタン
&lt;/figcaption>&lt;/figure>
パネル上の検索ボックスに&lt;code>live server&lt;/code>と入力し、検索結果の一番上にある&lt;code>Live Server&lt;/code>をクリックします。&lt;code>拡張機能:Live Server&lt;/code>タブが開くので、&lt;code>インストール&lt;/code>をクリックします。
&lt;figure id="figure-拡張機能live-serverタブ">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="./VSCode_Live_Server.png" alt="「拡張機能：Live Server」タブ" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
「拡張機能：Live Server」タブ
&lt;/figcaption>&lt;/figure>&lt;/p>
&lt;h2 id="補足-vscode日本語化">(補足) VSCode日本語化&lt;/h2>
&lt;p>検索ボックスに&lt;code>japanese&lt;/code>と入力し、検索結果の一番上にある拡張機能&lt;code>Japanese Language Pack for Visual Studio Code&lt;/code>をインストールすることで日本語化できます。
&lt;figure id="figure-japanese-language-pack-for-visual-studio-codeインストール済み">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="./VSCode_Japanese.png" alt="「Japanese Language Pack for Visual Studio Code」(インストール済み)" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
「Japanese Language Pack for Visual Studio Code」(インストール済み)
&lt;/figcaption>&lt;/figure>&lt;/p>
&lt;h1 id="2-ビルドしたゲームをvscodeで開く">2. ビルドしたゲームをVSCodeで開く&lt;/h1>
&lt;p>メニューの&lt;code>ファイル(F)&lt;/code>から&lt;code>フォルダを開く... Ctrl+K Ctrl+O&lt;/code>をクリックします。フォルダ選択ダイアログが表示されるので、出力された&lt;code>Build&lt;/code>フォルダと&lt;code>TemplateData&lt;/code>フォルダ、&lt;code>index.html&lt;/code>ファイルのあるフォルダを選択します。&lt;/p>
&lt;h1 id="3-ゲームをプレイ">3. ゲームをプレイ&lt;/h1>
&lt;p>正しくフォルダを開けていると画面右下に&lt;code>Go Live&lt;/code>ボタンが表示されます。このボタンをクリックするとブラウザが起動し、ゲームをプレイできます。
&lt;figure id="figure-go-live-ボタン">
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="./Live_Server_Go_Live.png" alt="Go Live ボタン" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;figcaption>
Go Live ボタン
&lt;/figcaption>&lt;/figure>
&lt;code>Go Live&lt;/code>があった場所に表示される&lt;code>Port:5050&lt;/code>をクリックすれば、ブラウザでのプレイを停止できます。VSCodeを閉じれば自動的に停止するはずですが、プレイを止める際にはボタンを押すことをおすすめします。&lt;/p></description></item><item><title>自己流ステージ作成方法</title><link>https://blog.opuappnavi.com/post/stage-create/</link><pubDate>Sat, 30 May 2020 10:17:55 +0900</pubDate><guid>https://blog.opuappnavi.com/post/stage-create/</guid><description>&lt;h1 id="はじめに">はじめに&lt;/h1>
&lt;p>初めまして、アプリNaviのヤマグチです。&lt;br>
本日、府大バーチャル学祭開催に合わせ、『巡回！デリバリー屋さん』を&lt;a href="http://appnavi.html.xdomain.jp/index.html" target="_blank" rel="noopener">特設ページ&lt;/a>にて公開させていただきました。遊んで、楽しんでもらえたのなら嬉しいです。&lt;/p>
&lt;p>今ゲームは2Dパズルアクションゲームで、ステージ作りにそれなりの時間を割きました。&lt;br>
そこで、前半はステージ作りをするとき僕がどう考えていたかについて、後半はゲーム内に実装したステージを作った時に考えていたことの一部について書きます。&lt;br>
あくまで僕自身の考え方であり他の方のものとは異なります。参考程度に読んでください。&lt;/p>
&lt;h1 id="ステージ作成で大切なこと">ステージ作成で大切なこと&lt;/h1>
&lt;p>この項では、僕がステージ作成で気にした方がいいと考えていることを書いていきます&lt;/p>
&lt;h2 id="1-ステージに意図を持たせる">1. ステージに意図を持たせる&lt;/h2>
&lt;p>皆さんはカードゲームをしたことがありますか。ない場合は武器やパーティをカスタム、編成するゲームを考えてください。カードゲームにおいて、何が一番いる能力だと思いますか。&lt;br>
プレイング、読み、運、色々あると思います。&lt;br>
僕の答えは構築力です。なぜ構築力なのかは、ここではあまり関係ないので省きますが、構築力が高いデッキはデッキ内のすべてのカードに採用する理由があります。完成された構築には意味のないカードはなく、製作者の意図、意志が反映されます。 限られたデッキ枚数に何を何枚採用するか。&lt;br>
言い換えると、限られたスペースに何をどのくらい配置するか、何かに似てますね。&lt;br>
そうです、ステージ作成です。特に今回のゲームでは、ステージは一画面に収まる量でなくてはダメでした。&lt;br>
そこで、ステージの枠組みをどうするか、設置物をどこに置くか等、それぞれの配置に自分なりの考えを持つことを意識して作成しました。&lt;/p>
&lt;h2 id="2-意味のないものを作る">2. 意味のないものを作る&lt;/h2>
&lt;p>前項で書いたことに早速矛盾しました。&lt;br>
しかし、意味のないものを作ることも必要です。遊んでくれる方は製作者の意図なんて知ったこっちゃありません。だからこそ、製作者にとっては無意味だとわかり切っているものにも意味があるんじゃないかと深読みしてくれます。 そうすれば、意味のないものを作ったつもりが意味のあるものを作れます。&lt;br>
意図的に意味のないものを作ることでステージ全体に遊び心を与えることができるのです。&lt;/p>
&lt;h2 id="3-ギミックの使い方を考える">3. ギミックの使い方を考える&lt;/h2>
&lt;p>今回はステージの数が少なく、一つ一つのステージも小さいです。なので、できる限り同じ使い方でギミックを使わないことを気にしました。&lt;br>
同じギミックでも、あるときはプラスの役割で使い、またある時はマイナスの役割で使うというようにギミックをより効果的に使うことを心がけました。&lt;/p>
&lt;h2 id="4-自分が楽しむ">4. 自分が楽しむ&lt;/h2>
&lt;p>これが一番大切な気がします。&lt;br>
作った人が作ったものに対しての理解が最も深いはずです。その人が楽しめないものを他の人が楽しめるとは思えません。作ったステージを自分自身が楽しめるようになることが望ましいです。 作っている時は、作っているステージが面白いかどうかわからなくなってきます。しかし自分が面白いと思えば、少なくとも世界で誰も楽しめないステージではなくなります。&lt;br>
僕は今回のゲーム内のステージでは僕が作ったステージが一番好きです。&lt;/p>
&lt;h1 id="実際に作ったステージの解説">実際に作ったステージの解説&lt;/h1>
&lt;p>この項では、僕が今回のゲームで作ったステージのちょっとした解説をしようと思います。&lt;br>
この先、ステージ9のネタバレを含みますのでプレイした後に読むことをお勧めします。
&lt;details class="spoiler " id="spoiler-0">
&lt;summary>&lt;code>以下ステージ9ネタバレ&lt;/code>&lt;/summary>
&lt;p>&lt;figure >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="./stage9.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
1の意図は、ステージ全体にコンセプトを持たせることです。
初めにコンセプトを決めておくことで僕自身の中で方向性がブレないようにしました。このステージ全体のコンセプトは「ステージ一周」でした。その時に右周りでも左回りでもクリアできるようにするということを目標にしました。
ステージ全体を荷物を取るエリアでそれぞれ区分けし、各エリアには入り口と出口を作り、周回方向によって入り口、出口が入れ替わるような配置にしました。
上の画像では、赤枠の示す上から落ちるブロックを擬似的な通行止めとして利用しています。
&lt;p>2の意味のないものは、どっち周りでもクリアできるという要素です。&lt;br>
別に両方から進める必要は全くありません。左回りの時は右回りのギミックは不必要で、右回りの時は左回りのギミックは不必要となります。&lt;br>
ただ、これがあることでこのステージの面白さが出ていると考えています。&lt;/p>
&lt;p>3のギミックの使い方は、先ほども挙げた落ちるブロックによるステージの区切りです。&lt;br>
他の僕の作ったステージでは、基本的にプレイヤーを倒すためだけのものでした。そこに他の役割である区切りという役割を持たせています。&lt;br>
この使い方はプラスとマイナスの両方の使い方というわけではありませんが、違った使い方をした一例ではあります。&lt;/p>
&lt;p>4の自分が楽しむに関しては、作ってる間すごく楽しかったです。コンセプトを思いついてからは非常にスムーズにステージ作成をすることができました。&lt;/p>
&lt;p>以上が、僕の作ったステージのちょっとした解説になります。あまり話しすぎても面白くないのでこの辺りで終わります。&lt;/p>
&lt;/p>
&lt;/details>&lt;/p>
&lt;h2 id="終わりに">終わりに&lt;/h2>
&lt;p>読んでいただきありがとうございました。&lt;br>
まさかブログまで書くことになると思っていませんでしたが、ゲームも含めてまあ良いものになったんじゃないかなあと思っています。&lt;br>
最後に、ゲームを遊んでいただいた方、このブログを読んでいただいた方ありがとうございました。それではまた何かの機会に。&lt;/p></description></item><item><title>Unity製ゲームをWebで共有する方法</title><link>https://blog.opuappnavi.com/post/unity-github-pages/</link><pubDate>Mon, 04 May 2020 20:17:22 +0900</pubDate><guid>https://blog.opuappnavi.com/post/unity-github-pages/</guid><description>&lt;p>Gitに詳しくない人向けに書いています。Gitに詳しい人は&lt;code>詳しくない人向け&lt;/code>の部分は読まなくて大丈夫です。&lt;/p>
&lt;h1 id="必要なもの">必要なもの&lt;/h1>
&lt;ul>
&lt;li>Unity&lt;/li>
&lt;li>GitHub アカウント&lt;/li>
&lt;li>Git：&lt;a href="https://git-scm.com/downloads" target="_blank" rel="noopener">ここ&lt;/a>からダウンロードできます&lt;/li>
&lt;/ul>
&lt;h1 id="1-unityでゲームをビルドする">1. Unityでゲームをビルドする&lt;/h1>
&lt;h2 id="11-build-settingsを開く">1.1 Build Settingsを開く&lt;/h2>
&lt;p>左上のメニューで&lt;code>File&lt;/code>&amp;gt;&lt;code>Build Settings&lt;/code>をクリックしてください。&lt;/p>
&lt;h2 id="12-プラットフォームの変更">1.2 プラットフォームの変更&lt;/h2>
&lt;p>&lt;code>WebGL&lt;/code>を選択し、&lt;code>Switch Platform&lt;/code>をクリックしてください。&lt;/p>
&lt;h2 id="13-ゲームをビルド">1.3 ゲームをビルド&lt;/h2>
&lt;p>&lt;code>Build&lt;/code>をクリックしてください。ビルド先はどこでも構いません。私は&lt;code>(プロジェクト名)/Builds/WebGL&lt;/code>を選択しています。&lt;/p>
&lt;h1 id="2-githubにアップロード">2. GitHubにアップロード&lt;/h1>
&lt;p>ビルドの結果、以下の3つのファイルが生成されます。&lt;/p>
&lt;ul>
&lt;li>&lt;code>Build&lt;/code>フォルダ&lt;/li>
&lt;li>&lt;code>TemplateData&lt;/code>フォルダ&lt;/li>
&lt;li>&lt;code>index.html&lt;/code>ファイル&lt;/li>
&lt;/ul>
&lt;p>これらのファイルをGitHubにアップロードします。&lt;br>
&lt;details class="spoiler " id="spoiler-0">
&lt;summary>詳しくない人向け&lt;/summary>
&lt;p>&lt;h2 id="21-githubにサインイン">2.1 GitHubにサインイン&lt;/h2>
&lt;p>&lt;a href="https://github.com/" target="_blank" rel="noopener">GitHub&lt;/a>にアクセスし、サインインしてください。&lt;/p>
&lt;h2 id="22-新しいリポジトリの作成">2.2 新しいリポジトリの作成&lt;/h2>
&lt;figure class="left" >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="./GitHub_New_Repository.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
`Repositories`の右にある`New`をクリックしてください。
&lt;figure class="left" >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="./GitHub_New_Repository2.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
`Repository name`は任意の名前で構いませんが、ゲームをプレイする人も見ることができるので注意してください。
`Public`と`Private`を選択できますが、`Public`を選択してください。
`Create repository`を選択してリポジトリを作成してください。
&lt;figure class="left" >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="./GitHub_New_Repository3.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
赤い枠で囲まれたボタンを押してください。左のURLがクリップボードにコピーされます。
&lt;h2 id="23-ファイルのアップロード">2.3 ファイルのアップロード&lt;/h2>
&lt;p>&lt;code>Git Bash&lt;/code>を起動してください。
起動時のフォルダは&lt;code>C:\Users\(ユーザー名)&lt;/code>なので、ビルド結果があるフォルダに移動してください。&lt;code>cd (フォルダ名)&lt;/code>コマンドで移動できます。
移動したら、以下のコマンドを一行ずつ実行してください。&lt;/p>
&lt;div class="alert alert-note">
&lt;div>
&lt;code>Git Bash&lt;/code>では&lt;code>Shift&lt;/code>+&lt;code>Insert&lt;/code>で貼り付けができます
&lt;/div>
&lt;/div>
&lt;pre>&lt;code class="language-bash">git init
git add .
git commit -m &amp;quot;Initial Commit&amp;quot;
git remote add origin (先ほどコピーしたURL)
git push -u origin master
&lt;/code>&lt;/pre>
&lt;/p>
&lt;/details>&lt;/p>
&lt;h1 id="3-webにゲームを公開">3. Webにゲームを公開&lt;/h1>
&lt;p>
&lt;figure class="left" >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="./GitHub_Pages.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
&lt;code>Settings&lt;/code>をクリックしてください。
&lt;figure class="left" >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="./GitHub_Pages2.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
スクロールし、&lt;code>GitHub Pages&lt;/code>の&lt;code>Source&lt;/code>の下にあるドロップダウンリストで&lt;code>master branch&lt;/code>を選択してください。&lt;/p>
&lt;h1 id="公開したゲームをプレイ">公開したゲームをプレイ&lt;/h1>
&lt;p>&lt;code>https://(ユーザー名).github.io/(リポジトリ名)/&lt;/code>というURLにアクセスすると、作ったゲームをプレイすることができます。&lt;/p></description></item><item><title>GitHub for Unityの紹介</title><link>https://blog.opuappnavi.com/post/github-for-unity/</link><pubDate>Thu, 30 Apr 2020 20:18:25 +0900</pubDate><guid>https://blog.opuappnavi.com/post/github-for-unity/</guid><description>&lt;h1 id="使用したunityのバージョン">使用したUnityのバージョン&lt;/h1>
&lt;p>Unity 2018.4.22f1&lt;/p>
&lt;h1 id="導入方法">導入方法&lt;/h1>
&lt;p>プロジェクトごとに行う必要があります。&lt;/p>
&lt;ol>
&lt;li>Asset Storeから「GitHub for Unity」をインポート&lt;/li>
&lt;li>メニューで&lt;code>Window&lt;/code>&amp;gt;&lt;code>GitHub&lt;/code>を選択&lt;br>
&lt;figure class="left" >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="./GitHub_Tab_Menu.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
GitHubタブが開きます。
&lt;figure class="left" >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="./GitHub_Tab.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/li>
&lt;li>&lt;strong>(初回のみ)&lt;/strong> &lt;code>Sign In&lt;/code>をクリック&lt;br>
&lt;figure class="left" >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="./GitHub_SignIn.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>
ダイアログが表示されるので、GitHubアカウントでサインインしてください。&lt;/li>
&lt;li>&lt;code>Initialize a git repository for this project&lt;/code>をクリック&lt;br>
少し待つと、タブの中身が変化します。&lt;br>
&lt;figure class="left" >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="./GitHub_AfterGitInit.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/li>
&lt;/ol>
&lt;h1 id="使い方">使い方&lt;/h1>
&lt;p>&lt;code>Changes&lt;/code>を選択してください。前回保存した状態から変更があったファイルが一覧表示されます。
&lt;figure class="left" >
&lt;div class="d-flex justify-content-center">
&lt;div class="w-100" >&lt;img src="./GitHub_Changes.png" alt="" loading="lazy" data-zoomable />&lt;/div>
&lt;/div>&lt;/figure>&lt;/p>
&lt;h2 id="変更を保存する">変更を保存する&lt;/h2>
&lt;ol>
&lt;li>リストから保存したい変更をチェックマークをクリックして選択&lt;/li>
&lt;li>&lt;code>Commit summary&lt;/code>に変更内容を記述&lt;/li>
&lt;li>&lt;code>Commit description&lt;/code>に変更内容の詳細を記述（任意）&lt;/li>
&lt;li>&lt;code>Commit to [master]&lt;/code>をクリック&lt;/li>
&lt;/ol>
&lt;h2 id="変更内容を確認する">変更内容を確認する&lt;/h2>
&lt;p>前回保存した状態と現在の状態との差分を見ることができます。
&lt;div class="alert alert-warning">
&lt;div>
差分を比較するソフトウェア(&lt;a href="https://forest.watch.impress.co.jp/library/software/winmerge/" target="_blank" rel="noopener">WinMerge&lt;/a>など)をインストールする必要があります。
&lt;/div>
&lt;/div>
&lt;/p>
&lt;ol>
&lt;li>リストから差分を見たいファイルを右クリック&lt;/li>
&lt;li>&lt;code>Show Diff&lt;/code>をクリック&lt;/li>
&lt;/ol>
&lt;h3 id="変更を取り消す">変更を取り消す&lt;/h3>
&lt;p>加えた変更を無かったことにして、前回保存した状態に戻すことができます。&lt;/p>
&lt;ol>
&lt;li>リストから変更を取り消したいファイルを右クリック&lt;/li>
&lt;li>&lt;code>Discard&lt;/code>をクリック&lt;/li>
&lt;/ol>
&lt;h1 id="その他">その他&lt;/h1>
&lt;h2 id="比較ソフトウェアを変更したい">比較ソフトウェアを変更したい&lt;/h2>
&lt;p>比較ソフトウェアが複数インストールされていて、変更したい場合&lt;/p>
&lt;ol>
&lt;li>UnityのPreferenceを開く&lt;/li>
&lt;li>&lt;code>External Tools&lt;/code>を選択&lt;/li>
&lt;li>&lt;code>Revision Controll Diff/Merge&lt;/code>でソフトウェアを選択&lt;/li>
&lt;/ol>
&lt;hr>
&lt;details class="spoiler " id="spoiler-6">
&lt;summary>GitHubやGitに詳しい人向け&lt;/summary>
&lt;p>&lt;h2 id="revert">Revert&lt;/h2>
&lt;ol>
&lt;li>&lt;code>History&lt;/code>を選択&lt;/li>
&lt;li>コミットを右クリック&lt;/li>
&lt;li>&lt;code>Revert&lt;/code>をクリック&lt;/li>
&lt;/ol>
&lt;/p>
&lt;/details></description></item><item><title>Truck Quiz</title><link>https://blog.opuappnavi.com/post/truck-quiz/</link><pubDate>Tue, 28 Apr 2020 15:07:58 +0900</pubDate><guid>https://blog.opuappnavi.com/post/truck-quiz/</guid><description>&lt;p>Unityについて勉強するため春休みの間に作成した、&amp;ldquo;Truck Quiz&amp;quot;を紹介します。&lt;/p>
&lt;h1 id="ゲームの説明">ゲームの説明&lt;/h1>
&lt;p>某有名クイズ番組のクイズを模したゲームです。
2択問題が5問出題されます。間違えてた時点でゲームオーバーです。
キーボード操作、タッチ操作の両方に対応しています。&lt;/p>
&lt;div id="unity_webgl_0_1" style="width: 100%; margin: 15px 0; background: white; border-radius: 15px;">
&lt;div style="position: relative;">
&lt;div id="unity_webgl_0_2" style="height: 0;">
&lt;iframe id="unity_webgl_0_3" src="https://juris710.github.io/TruckQuizSample/" allowfullscreen>&lt;/iframe>
&lt;/div>
&lt;/div>
&lt;/div>
&lt;script>
document.getElementById("unity_webgl_0_2").style.paddingBottom = 100 * 700 / 980 + "%";
function set_width() {
const w = 980 ;
const h = 700 ;
const client_w = document.getElementById("unity_webgl_0_2").clientWidth;
const per = client_w / w;
const rev = 100 / per;
const iframe = document.getElementById("unity_webgl_0_3");
iframe.height = rev + "%";
iframe.width = rev + "%";
iframe.style = "position: absolute; top: 0; left: 0; transform:scale(" + per + ");-o-transform:scale(" + per + ");-webkit-transform:scale(" + per + ");-moz-transform:scale(" + per + ");-ms-transform:scale(" + per + ");transform-origin:top left; border: 0;"
}
set_width();
window.onresize = function(){ set_width(); };
&lt;/script>
&lt;h1 id="工夫した点">工夫した点&lt;/h1>
&lt;ul>
&lt;li>クイズの問題やゲーム設定をJSONファイルで管理&lt;/li>
&lt;li>画像のアスペクト比を維持するように&lt;/li>
&lt;li>解答の取り消し、問題の差し替え機能実装&lt;/li>
&lt;li>ゲーム内の文章ほぼ全てにフリガナを付ける（フリガナ表示・非表示切り替え可能）&lt;/li>
&lt;li>問題の解説に文章だけでなく選択肢の画像も利用できるように&lt;/li>
&lt;/ul>
&lt;h1 id="実装の概説">実装の概説&lt;/h1>
&lt;details class="spoiler " id="spoiler-1">
&lt;summary>Unityに詳しい人向け&lt;/summary>
&lt;p>&amp;ldquo;Truck Quiz&amp;quot;を主に動かしているのは&lt;code>StateMachineBehaviour&lt;/code>です。&lt;code>StateMachineBehaviour&lt;/code>について軽く説明すると、アニメーションの開始時、終了時、Update時(MonoBehaviourのUpdate関数同様、アニメーションの再生中定期的に呼ばれる)に任意の処理を挟むことのできるクラスです。&lt;br>
トロッコとUIで2つのAnimatorがあり、「選択肢を選んだアニメーション」が終了したら「トロッコが曲がるアニメーション」を開始する、みたいな処理をGameManagerクラス内で実装しています。&lt;/p>
&lt;/details>
&lt;h1 id="改良予定">改良予定&lt;/h1>
&lt;details class="spoiler " id="spoiler-2">
&lt;summary>Unityに詳しい人向け&lt;/summary>
&lt;p>&lt;h2 id="assetbundleを使用した画像管理">AssetBundleを使用した画像管理&lt;/h2>
&lt;p>現状Resourceクラスで問題の画像を管理していますが、公式が「Resourceクラスは使うな」と言っているので、AssetBundleへの切替を検討しています&lt;/p>
&lt;h2 id="unityバージョンのアップグレード">Unityバージョンのアップグレード&lt;/h2>
&lt;p>現在使用しているUnityのバージョンは2018ですが、2018ではpreview版である&lt;code>Input System&lt;/code>を使用したいため、2019へのアップグレードを検討しています。&lt;/p>
&lt;h2 id="デザイン面の改善">デザイン面の改善&lt;/h2>
&lt;p>UIデザインの改善を検討しています。&lt;/p>
&lt;/p>
&lt;/details></description></item></channel></rss>